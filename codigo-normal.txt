#ifndef INTERPRETE_H
#define INTERPRETE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ncurses.h>
#include <unistd.h>
#include <panel.h> //nueva libreria para paneles de ncurses
#include <time.h>
#include "operaciones.h"
#include "pcb.h"
#include "kbhit.h"

static WINDOW *win_ejecucion = NULL;
static WINDOW *win_listos = NULL;
static WINDOW *win_terminados = NULL;
static WINDOW *win_nuevos = NULL;
static WINDOW *win_ejec = NULL;
static WINDOW *win_term = NULL;
// static WINDOW *win_nuevos = NULL;
// static WINDOW *win_listos = NULL;

static PANEL *panel_ejecucion = NULL;
static PANEL *panel_listos = NULL;
static PANEL *panel_terminados = NULL;
static PANEL *panel_nuevos = NULL;

static void dibujar_nuevos(WINDOW *win_nuevos, int fila_base);
static void dibujar_listos(WINDOW *win_listos, int fila_base);

/* --- Funciones utilitarias --- */
static void rtrim(char *s)
{
    size_t n = strlen(s);
    while (n && (s[n - 1] == '\n' || s[n - 1] == '\r'))
        s[--n] = '\0';
}

static void trim(char *s)
{
    char *p = s;
    while (*p == ' ' || *p == '\t')
        p++;
    if (p != s)
        memmove(s, p, strlen(p) + 1);
    size_t n = strlen(s);
    while (n && (s[n - 1] == ' ' || s[n - 1] == '\t'))
        s[--n] = '\0';
}

static int RegistroValido(const char *var)
{
    return (strcmp(var, "Ax") == 0 || strcmp(var, "Bx") == 0 ||
            strcmp(var, "Cx") == 0 || strcmp(var, "Dx") == 0);
}

static int Numero(const char *s)
{
    if (s == NULL)
        return 0;
    int i = 0;
    if (s[0] == '-' && s[1] != '\0')
        i = 1;
    for (; s[i]; i++)
        if (s[i] < '0' || s[i] > '9')
            return 0;
    return 1;
}

/* --- Listas globales --- */
static PCB *lista_listos = NULL;
static PCB *lista_terminados = NULL;
static PCB *lista_nuevos = NULL; /* nueva lista donde se ponen los procesos al leerlos */
static PCB *pcb_ejecucion = NULL;

/* --- Registros globales (para simulacion de cargar/guardar contexto) --- */
static int gAx = 0, gBx = 0, gCx = 0, gDx = 0;
/* Quantum por defecto (puedes cambiarlo) */
static int Q = 4;

/* --- Funciones auxiliares para listas --- */
static void push_listo(PCB *p)
{
    /*p->siguiente = NULL;
    if (!lista_listos)
        lista_listos = p;
    else
    {
        PCB *q = lista_listos;
        while (q->siguiente)
            q = q->siguiente;
        q->siguiente = p;
    }*/
    /*nueva contenido*/
    p->siguiente = NULL;
    if (!lista_listos) {
        lista_listos = p;
        return;
    }

    /* Si p tiene mayor prioridad (número menor) que el primero -> se pone al frente */
    if (p->prioridad < lista_listos->prioridad) {
        p->siguiente = lista_listos;
        lista_listos = p;
        return;
    }

    /* Recorrer hasta encontrar la posición correcta:
       - avanzar mientras siguiente exista y tenga prioridad <= prioridad_de_p
       - de esta forma, si encuentras nodos con misma prioridad, avanzas hasta el final
         del grupo, respetando FIFO dentro de la prioridad. */
    PCB *q = lista_listos;
    while (q->siguiente && q->siguiente->prioridad <= p->prioridad) {
        q = q->siguiente;
    }

    /* Insertar después de q */
    p->siguiente = q->siguiente;
    q->siguiente = p;
}

static PCB *pop_listo(void)
{
    if (!lista_listos)
        return NULL;
    PCB *h = lista_listos;
    lista_listos = h->siguiente;
    h->siguiente = NULL;
    return h;
}

static void anexar_terminado_final(PCB *src)
{
    PCB *n = (PCB *)malloc(sizeof(PCB));
    if (!n)
        return;
    *n = *src;
    n->file = NULL; // no guardamos el FILE en la lista de terminados
    n->siguiente = NULL;

    if (!lista_terminados)
        lista_terminados = n;
    else
    {
        PCB *q = lista_terminados;
        while (q->siguiente)
            q = q->siguiente;
        q->siguiente = n;
    }
}

/* --- Nueva lista `nuevos` --- */
static void push_nuevo(PCB *p)
{
    p->siguiente = NULL;
    if (!lista_nuevos)
        lista_nuevos = p;
    else
    {
        PCB *q = lista_nuevos;
        while (q->siguiente)
            q = q->siguiente;
        q->siguiente = p;
    }
}

/* Cuenta procesos en la lista de listos (sin incluir el que está en ejecucion) */
static int contar_listos(void)
{
    int c = 0;
    PCB *q = lista_listos;
    while (q)
    {
        c++;
        q = q->siguiente;
    }
    return c;
}

/* Planificador a largo plazo: mueve procesos desde `nuevos` hacia `listos`
   hasta que `listos` alcance el límite de 3 procesos. */
/*
static void planificador_largo_plazo(void)
{
    while (contar_listos() < 3 && lista_nuevos)
    {
        PCB *p = lista_nuevos;
        lista_nuevos = p->siguiente;
        p->siguiente = NULL;
        strncpy(p->status, "listo", sizeof(p->status)-1);
        p->status[sizeof(p->status)-1] = '\0';
        push_listo(p);
    }
}*/

static void planificador_largo_plazo(void)
{
    // Mover procesos desde NUEVOS → LISTOS (máximo 3 listos)
    while (contar_listos() < 3 && lista_nuevos)
    {
        PCB *p = lista_nuevos;
        lista_nuevos = p->siguiente; // avanzar en la lista NUEVOS
        p->siguiente = NULL;

        // Actualizar estado del proceso
        strncpy(p->status, "listo", sizeof(p->status) - 1);
        p->status[sizeof(p->status) - 1] = '\0';

        // Encolar el proceso en la lista de listos
        push_listo(p);
    }

    // Si ya no quedan procesos NUEVOS, aseguramos dejar la lista vacía
    if (!lista_nuevos)
        lista_nuevos = NULL;

    // Redibujar paneles si están activos (modo ncurses)
    if (win_nuevos && win_listos)
    {
        dibujar_nuevos(win_nuevos, 2);
        dibujar_listos(win_listos, 2);
        update_panels();
        doupdate();
    }
}

/* --- Guardar/Cargar contexto --- */
// Guarda los registros globales en el PCB (cuando pasa Ejecucion -> Listos/Terminados)
static void GuardarContexto(PCB *p)
{
    if (!p)
        return;
    p->Ax = gAx;
    p->Bx = gBx;
    p->Cx = gCx;
    p->Dx = gDx;
}

// Carga los registros del PCB a los registros globales (cuando pasa Listos -> Ejecucion)
static void CargarContexto(PCB *p)
{
    if (!p)
        return;
    gAx = p->Ax;
    gBx = p->Bx;
    gCx = p->Cx;
    gDx = p->Dx;
}

/* --- Función Kill --- */
static int kill_proceso(int id)
{
    PCB *prev = NULL;
    PCB *curr = lista_listos;

    // Buscar en lista de listos
    while (curr)
    {
        if (curr->id == id)
        {
            // Sacar de la lista de listos
            if (prev)
                prev->siguiente = curr->siguiente;
            else
                lista_listos = curr->siguiente;

            strncpy(curr->status, "Killed", sizeof(curr->status) - 1);
            GuardarContexto(curr);
            anexar_terminado_final(curr);

            /* Después de matar un proceso, mover nuevos a listos si hay espacio */
            planificador_largo_plazo();

            printf("Proceso con ID %d finalizado (Killed)\n", id);
            if (curr->file)
                fclose(curr->file);
            free(curr);
            return 1;
        }
        prev = curr;
        curr = curr->siguiente;
    }

    // Buscar en ejecución
    if (pcb_ejecucion && pcb_ejecucion->id == id)
    {
        strncpy(pcb_ejecucion->status, "Killed", sizeof(pcb_ejecucion->status) - 1);
        GuardarContexto(pcb_ejecucion);
        anexar_terminado_final(pcb_ejecucion);

        /* Mover nuevos a listos si hay espacio */
        planificador_largo_plazo();

        printf("Proceso con ID %d finalizado (Killed)\n", id);

        if (pcb_ejecucion->file)
            fclose(pcb_ejecucion->file);
        free(pcb_ejecucion);
        pcb_ejecucion = NULL;
        return 1;
    }

    // No encontrado
    printf("Proceso con id: %d no existe\n", id);
    return 0;
}

/* --- Interfaz ncurses con paneles --- */
static void inicializar_paneles()
{
    int ancho = COLS - 2;
    int alto = LINES / 3 - 1;

    // Crear ventanas
    win_ejecucion = newwin(alto, ancho, 1, 1);
    win_listos = newwin(alto, ancho, alto + 2, 1);
    win_terminados = newwin(alto, ancho, 2 * (alto + 1) + 1, 1);

    // Crear paneles
    panel_ejecucion = new_panel(win_ejecucion);
    panel_listos = new_panel(win_listos);
    panel_terminados = new_panel(win_terminados);

    // Dibujar bordes y títulos
    box(win_ejecucion, 0, 0);
    mvwprintw(win_ejecucion, 0, 2, " Ejecucion ");

    box(win_listos, 0, 0);
    mvwprintw(win_listos, 0, 2, " Listos/Preparados ");

    box(win_terminados, 0, 0);
    mvwprintw(win_terminados, 0, 2, " Terminados/Finalizados ");

    update_panels();
    doupdate();
}

/* Limpieza de paneles */
static void destruir_paneles()
{
    if (panel_ejecucion)
        del_panel(panel_ejecucion);
    if (panel_listos)
        del_panel(panel_listos);
    if (panel_terminados)
        del_panel(panel_terminados);

    if (win_ejecucion)
        delwin(win_ejecucion);
    if (win_listos)
        delwin(win_listos);
    if (win_terminados)
        delwin(win_terminados);
}

/* --- Interfaz ncurses --- */
static void dibujar_encabezados()
{
    /*
    clear();
    mvprintw(0, 0, "Ejecucion:");
    mvprintw(2, 0, "ID   Ax        Bx        Cx        Dx        Pc        IR                  nombre         Status");
    mvprintw(3, 0, "==================================================================================================");

    mvprintw(6, 0, "Listos/Preparados:");
    mvprintw(8, 0, "ID   Ax        Bx        Cx        Dx        Pc        IR                  nombre         Status");
    mvprintw(9, 0, "--------------------------------------------------------------------------------------------------");

    mvprintw(12, 0, "Terminados/Finalizados:");
    mvprintw(14, 0, "ID   Ax        Bx        Cx        Dx        Pc        IR                  nombre         Status");
    mvprintw(15, 0, "==================================================================================================");

    mvprintw(LINES-1, 0, "Presiona 'q' o ESC para detener la simulacion.");*/
    werase(win_ejecucion);
    werase(win_listos);
    werase(win_terminados);

    box(win_ejecucion, 0, 0);
    box(win_listos, 0, 0);
    box(win_terminados, 0, 0);

    mvwprintw(win_ejecucion, 0, 2, " Ejecucion ");
    mvwprintw(win_listos, 0, 2, " Listos/Preparados ");
    mvwprintw(win_terminados, 0, 2, " Terminados/Finalizados ");

    mvwprintw(win_ejecucion, 1, 1, "ID   Ax        Bx        Cx        Dx        Pc        IR           nombre         Status");
    mvwprintw(win_listos, 1, 1, "ID   Ax        Bx        Cx        Dx        Pc        IR              nombre         Status");
    mvwprintw(win_terminados, 1, 1, "ID   Ax        Bx        Cx        Dx        Pc        IR          nombre         Status");

    update_panels();
    doupdate();
}

/* --- Dibujar procesos nuevos --- */
static void dibujar_nuevos(WINDOW *win_nuevos, int fila_base)
{
    /*werase(win_nuevos);
    box(win_nuevos, 0, 0);
    wattron(win_nuevos, COLOR_PAIR(5));
    mvwprintw(win_nuevos, 0, 2, " NUEVOS ");
    wattroff(win_nuevos, COLOR_PAIR(5));

    int fila = fila_base;
    PCB *q = lista_nuevos;
    while (q)
    {
        mvwprintw(win_nuevos, fila, 1, "%-4d %-7d %-7d %-7d %-7d %-7d %-20s %-10s%s",
                  q->id, q->Ax, q->Bx, q->Cx, q->Dx, q->Pc,
                  "------", q->nombre, q->status);
        fila++;
        q = q->siguiente;
    }
    wrefresh(win_nuevos);*/
    werase(win_nuevos);
    box(win_nuevos, 0, 0);
    wattron(win_nuevos, COLOR_PAIR(5));
    mvwprintw(win_nuevos, 0, 2, " NUEVOS ");
    wattroff(win_nuevos, COLOR_PAIR(5));

    int fila = fila_base;
    PCB *q = lista_nuevos;
    mvwprintw(win_nuevos, 1, 1, "ID  Pr  Ax  Bx  Cx  Dx  Pc  nombre");
    fila = 2;
    while (q)
    {
        mvwprintw(win_nuevos, fila, 1, "%-3d %-3d %-4d %-4d %-4d %-4d %-4d %-s",
                  q->id, q->prioridad, q->Ax, q->Bx, q->Cx, q->Dx, q->Pc, q->nombre);
        fila++;
        q = q->siguiente;
    }
    wrefresh(win_nuevos);
}

/* --- Dibujar procesos listos --- */
static void dibujar_listos(WINDOW *win_listos, int fila_base)
{
    /*werase(win_listos);
    box(win_listos, 0, 0);
    wattron(win_listos, COLOR_PAIR(2));
    mvwprintw(win_listos, 0, 2, " LISTOS ");
    wattroff(win_listos, COLOR_PAIR(2));

    int fila = fila_base;
    PCB *q = lista_listos;
    while (q)
    {
        mvwprintw(win_listos, fila, 1, "%-4d %-7d %-7d %-7d %-7d %-7d %-20s %-10s%s",
                  q->id, q->Ax, q->Bx, q->Cx, q->Dx, q->Pc,
                  "------", q->nombre, q->status);
        fila++;
        q = q->siguiente;
    }
    wrefresh(win_listos);*/
    werase(win_listos);
    box(win_listos, 0, 0);
    wattron(win_listos, COLOR_PAIR(2));
    mvwprintw(win_listos, 0, 2, " LISTOS ");
    wattroff(win_listos, COLOR_PAIR(2));

    int fila = fila_base;
    PCB *q = lista_listos;
    mvwprintw(win_listos, 1, 1, "ID  Pr  Ax       Bx       Cx       Dx       Pc       IR               nombre         Status");
    mvwhline(win_listos, 2, 1, ACS_HLINE, COLS/2 - 4);
    fila = 3;
    while (q)
    {
        mvwprintw(win_listos, fila, 1, "%-3d %-3d %-8d %-8d %-8d %-8d %-8d %-18s %-14s %s",
                  q->id, q->prioridad, q->Ax, q->Bx, q->Cx, q->Dx, q->Pc,
                  "------", q->nombre, q->status);
        fila++;
        q = q->siguiente;
    }
    wrefresh(win_listos);
}

/* --- Dibujar procesos terminados --- */
static void dibujar_terminados(WINDOW *win_term, int fila_base)
{
    /*werase(win_term);
    box(win_term, 0, 0);
    wattron(win_term, COLOR_PAIR(3));
    mvwprintw(win_term, 0, 2, " TERMINADOS ");
    wattroff(win_term, COLOR_PAIR(3));

    int fila = fila_base;
    PCB *q = lista_terminados;
    while (q)
    {
        mvwprintw(win_term, fila, 1, "%-4d %-7d %-7d %-7d %-7d %-7d %-20s %-10s%s",
                  q->id, q->Ax, q->Bx, q->Cx, q->Dx, q->Pc,
                  q->IR, q->nombre, q->status);
        fila++;
        q = q->siguiente;
    }
    wrefresh(win_term);*/
    werase(win_term);
    box(win_term, 0, 0);
    wattron(win_term, COLOR_PAIR(3));
    mvwprintw(win_term, 0, 2, " TERMINADOS ");
    wattroff(win_term, COLOR_PAIR(3));

    int fila = fila_base;
    PCB *q = lista_terminados;
    mvwprintw(win_term, 1, 1, "ID  Pr  Ax  Bx  Cx  Dx  Pc  IR  nombre  Status");
    fila = 2;
    while (q)
    {
        mvwprintw(win_term, fila, 1, "%-3d %-3d %-4d %-4d %-4d %-4d %-4d %-18s %-14s %s",
                  q->id, q->prioridad, q->Ax, q->Bx, q->Cx, q->Dx, q->Pc,
                  q->IR, q->nombre, q->status);
        fila++;
        q = q->siguiente;
    }
    wrefresh(win_term);
}

/* --- Ejecución de instrucciones --- */
static int ejecutar_instruccion_linea(PCB *p, const char *linea)
{
    char buf[128];
    strncpy(buf, linea, sizeof(buf) - 1);
    buf[sizeof(buf) - 1] = '\0';
    rtrim(buf);
    if (buf[0] == ';' || buf[0] == '\0')
        return 0;

    char inst[16] = "", rest[64] = "";
    char var[32] = "", valstr[32] = "";

    if (sscanf(buf, "%15s %63[^\n]", inst, rest) < 1)
    {
        strncpy(p->status, "Error", sizeof(p->status) - 1);
        GuardarContexto(p);
        return -1;
    }
    trim(inst);
    trim(rest);

    if (rest[0])
    {
        char copy[64];
        strncpy(copy, rest, sizeof(copy) - 1);
        copy[sizeof(copy) - 1] = '\0';
        char *tok = strtok(copy, ",");
        if (tok)
        {
            strncpy(var, tok, sizeof(var) - 1);
            var[sizeof(var) - 1] = '\0';
            trim(var);
        }
        tok = strtok(NULL, ",");
        if (tok)
        {
            strncpy(valstr, tok, sizeof(valstr) - 1);
            valstr[sizeof(valstr) - 1] = '\0';
            trim(valstr);
        }
        tok = strtok(NULL, ",");
        if (tok)
        {
            strncpy(p->status, "Error", sizeof(p->status) - 1);
            GuardarContexto(p);
            return -1;
        }
    }

    char tempIR[128];
    if (var[0] && valstr[0])
        snprintf(tempIR, sizeof(tempIR), "%s %s,%s", inst, var, valstr);
    else if (var[0])
        snprintf(tempIR, sizeof(tempIR), "%s %s", inst, var);
    else
        snprintf(tempIR, sizeof(tempIR), "%s", inst);
    strncpy(p->IR, tempIR, sizeof(p->IR) - 1);
    p->IR[sizeof(p->IR) - 1] = '\0';

    if (strcmp(inst, "END") == 0)
    {
        strncpy(p->status, "Correcto", sizeof(p->status) - 1);
        return 1;
    }

    if (var[0] && !RegistroValido(var))
    {
        strncpy(p->status, "Error", sizeof(p->status) - 1);
        GuardarContexto(p);
        return -1;
    }

    // Verificar formato según instrucción
    if (strcmp(inst, "INC") == 0 || strcmp(inst, "DEC") == 0)
    {
        if (valstr[0])
        {
            strncpy(p->status, "Error", sizeof(p->status) - 1);
            GuardarContexto(p);
            return -1;
        }
    }
    else if (strcmp(inst, "MOV") == 0 || strcmp(inst, "ADD") == 0 ||
             strcmp(inst, "SUB") == 0 || strcmp(inst, "MUL") == 0 ||
             strcmp(inst, "DIV") == 0)
    {
        if (!valstr[0])
        {
            strncpy(p->status, "Error", sizeof(p->status) - 1);
            GuardarContexto(p);
            return -1;
        }
        if (!Numero(valstr))
        {
            strncpy(p->status, "Error", sizeof(p->status) - 1);
            GuardarContexto(p);
            return -1;
        }
    }
    else
    {
        strncpy(p->status, "Error", sizeof(p->status) - 1);
        GuardarContexto(p);
        return -1;
    }

    int valor = 0;
    if (valstr[0])
        valor = atoi(valstr);

    strncpy(p->status, "Correcto", sizeof(p->status) - 1);

    // Ahora las operaciones se realizan sobre los registros globales (gAx, gBx...)
    if (strcmp(inst, "MOV") == 0)
    {
        if (strcmp(var, "Ax") == 0)
            gAx = mov(gAx, valor);
        else if (strcmp(var, "Bx") == 0)
            gBx = mov(gBx, valor);
        else if (strcmp(var, "Cx") == 0)
            gCx = mov(gCx, valor);
        else if (strcmp(var, "Dx") == 0)
            gDx = mov(gDx, valor);
    }
    else if (strcmp(inst, "ADD") == 0)
    {
        if (strcmp(var, "Ax") == 0)
            gAx = add(gAx, valor);
        else if (strcmp(var, "Bx") == 0)
            gBx = add(gBx, valor);
        else if (strcmp(var, "Cx") == 0)
            gCx = add(gCx, valor);
        else if (strcmp(var, "Dx") == 0)
            gDx = add(gDx, valor);
    }
    else if (strcmp(inst, "SUB") == 0)
    {
        if (strcmp(var, "Ax") == 0)
            gAx = sub(gAx, valor);
        else if (strcmp(var, "Bx") == 0)
            gBx = sub(gBx, valor);
        else if (strcmp(var, "Cx") == 0)
            gCx = sub(gCx, valor);
        else if (strcmp(var, "Dx") == 0)
            gDx = sub(gDx, valor);
    }
    else if (strcmp(inst, "MUL") == 0)
    {
        if (strcmp(var, "Ax") == 0)
            gAx = mul(gAx, valor);
        else if (strcmp(var, "Bx") == 0)
            gBx = mul(gBx, valor);
        else if (strcmp(var, "Cx") == 0)
            gCx = mul(gCx, valor);
        else if (strcmp(var, "Dx") == 0)
            gDx = mul(gDx, valor);
    }
    else if (strcmp(inst, "DIV") == 0)
    {
        if (valor == 0)
        {
            strncpy(p->status, "Error", sizeof(p->status) - 1);
            GuardarContexto(p);
            return -1;
        }
        if (strcmp(var, "Ax") == 0)
            gAx = divi(gAx, valor);
        else if (strcmp(var, "Bx") == 0)
            gBx = divi(gBx, valor);
        else if (strcmp(var, "Cx") == 0)
            gCx = divi(gCx, valor);
        else if (strcmp(var, "Dx") == 0)
            gDx = divi(gDx, valor);
    }
    else if (strcmp(inst, "INC") == 0)
    {
        if (strcmp(var, "Ax") == 0)
            gAx = inc(gAx);
        else if (strcmp(var, "Bx") == 0)
            gBx = inc(gBx);
        else if (strcmp(var, "Cx") == 0)
            gCx = inc(gCx);
        else if (strcmp(var, "Dx") == 0)
            gDx = inc(gDx);
    }
    else if (strcmp(inst, "DEC") == 0)
    {
        if (strcmp(var, "Ax") == 0)
            gAx = dec(gAx);
        else if (strcmp(var, "Bx") == 0)
            gBx = dec(gBx);
        else if (strcmp(var, "Cx") == 0)
            gCx = dec(gCx);
        else if (strcmp(var, "Dx") == 0)
            gDx = dec(gDx);
    }

    return 0;
}

static void planificador_corto_plazo(WINDOW *win_ejec, WINDOW *win_listos, WINDOW *win_term)
{
    // === Bucle principal (planificador a corto plazo) ===
    while ((pcb_ejecucion = pop_listo()) != NULL)
    {
        strncpy(pcb_ejecucion->status, "Ejecucion", sizeof(pcb_ejecucion->status) - 1);
        CargarContexto(pcb_ejecucion);

        char linea[128];
        int instrucciones_ejecutadas = 0;

        while (fgets(linea, sizeof(linea), pcb_ejecucion->file))
        {
            rtrim(linea);
            if (linea[0] == ';' || linea[0] == '\0')
                continue;

            int fin = ejecutar_instruccion_linea(pcb_ejecucion, linea);
            pcb_ejecucion->Pc++;
            instrucciones_ejecutadas++;

            // === Control por teclado ===
            /*
            if (kbhit())
            {
                int ch = getchar();
                if (ch == 'q' || ch == 'Q' || ch == 27)
                {
                    mvwprintw(win_ejec, 8, 2, "[Q] Interrupción detectada. Cancelando...");
                    wrefresh(win_ejec);
                    usleep(800000);
                    endwin();
                    printf("\n\n[Ejecución interrumpida]\n");
                    return;
                }
                else if (ch == 'p' || ch == 'P')
                {
                    wattron(win_ejec, COLOR_PAIR(4));
                    mvwprintw(win_ejec, 8, 2, "[P] Pausado. Presiona 'R' para reanudar...");
                    wattroff(win_ejec, COLOR_PAIR(4));
                    wrefresh(win_ejec);
                    int ch2;
                    do
                    {
                        usleep(100000);
                        if (kbhit())
                        {
                            ch2 = getchar();
                            if (ch2 == 'r' || ch2 == 'R')
                            {
                                mvwprintw(win_ejec, 8, 2, "Reanudando...                                 ");
                                wrefresh(win_ejec);
                                break;
                            }
                        }
                    } while (1);
                }
            }*/
            // === Control por teclado ===
            if (kbhit())
            {
                int ch = getchar();

                // --- Interrupción total ---
                if (ch == 'q' || ch == 'Q' || ch == 27) // 27 = tecla ESC
                {
                    wattron(win_ejec, COLOR_PAIR(1));
                    mvwprintw(win_ejec, 8, 2, "[Q] Interrupción detectada. Cancelando ejecución global...");
                    wattroff(win_ejec, COLOR_PAIR(1));
                    wrefresh(win_ejec);
                    usleep(800000);

                    // --- Liberar procesos de todas las listas ---
                    
                    PCB *tmp;
                    while (lista_nuevos)
                    {
                        tmp = lista_nuevos;
                        lista_nuevos = tmp->siguiente;
                        if (tmp->file)
                            fclose(tmp->file);
                        free(tmp);
                    }
                    while (lista_listos)
                    {
                        tmp = lista_listos;
                        lista_listos = tmp->siguiente;
                        if (tmp->file)
                            fclose(tmp->file);
                        free(tmp);
                    }
                    while (lista_terminados)
                    {
                        tmp = lista_terminados;
                        lista_terminados = tmp->siguiente;
                        if (tmp->file)
                            fclose(tmp->file);
                        free(tmp);
                    } 

                    // --- Cerrar ncurses limpiamente ---
                    endwin();

                    printf("\n[Ejecución interrumpida por el usuario]\n");
                    printf("[Todas las listas han sido liberadas correctamente]\n\n");
                    return; // <- Regresa al main() sin cerrar el programa
                }

                // --- Pausar ejecución ---
                else if (ch == 'p' || ch == 'P')
                {
                    wattron(win_ejec, COLOR_PAIR(4));
                    mvwprintw(win_ejec, 8, 2, "[P] Ejecución pausada. Presiona 'R' para reanudar...");
                    wattroff(win_ejec, COLOR_PAIR(4));
                    wrefresh(win_ejec);

                    int ch2;
                    while (1)
                    {
                        usleep(100000);
                        if (kbhit())
                        {
                            ch2 = getchar();

                            // Reanudar
                            if (ch2 == 'r' || ch2 == 'R')
                            {
                                mvwprintw(win_ejec, 8, 2, "Reanudando ejecución...                        ");
                                wrefresh(win_ejec);
                                usleep(300000);
                                break;
                            }

                            // Interrumpir también desde pausa
                            else if (ch2 == 'q' || ch2 == 'Q' || ch2 == 27)
                            {
                                mvwprintw(win_ejec, 8, 2, "[Q] Interrupción detectada durante pausa...");
                                wrefresh(win_ejec);
                                usleep(800000);

                                // liberar listas
                                PCB *tmp;
                                while (lista_nuevos)
                                {
                                    tmp = lista_nuevos;
                                    lista_nuevos = tmp->siguiente;
                                    if (tmp->file)
                                        fclose(tmp->file);
                                    free(tmp);
                                }
                                while (lista_listos)
                                {
                                    tmp = lista_listos;
                                    lista_listos = tmp->siguiente;
                                    if (tmp->file)
                                        fclose(tmp->file);
                                    free(tmp);
                                }
                                while (lista_terminados)
                                {
                                    tmp = lista_terminados;
                                    lista_terminados = tmp->siguiente;
                                    if (tmp->file)
                                        fclose(tmp->file);
                                    free(tmp);
                                }

                                endwin();
                                printf("\n[Ejecución interrumpida durante pausa]\n");
                                printf("[Todas las listas han sido liberadas correctamente]\n\n");
                                return;
                            }
                        }
                    }
                }
            }

            // === Dibujar ejecución ===
            werase(win_ejec);
            box(win_ejec, 0, 0);
            wattron(win_ejec, COLOR_PAIR(4));
            mvwprintw(win_ejec, 0, 2, " EJECUCION (Quantum = %d) ", Q);
            wattroff(win_ejec, COLOR_PAIR(4));

            mvwprintw(win_ejec, 2, 2, "ID   Ax      Bx      Cx      Dx      Pc      IR                  Nombre        Estado");
            mvwhline(win_ejec, 3, 2, ACS_HLINE, COLS - 6);
            mvwprintw(win_ejec, 4, 2, "%-4d %-7d %-7d %-7d %-7d %-7d %-20s %-12s %s",
                      pcb_ejecucion->id, gAx, gBx, gCx, gDx, pcb_ejecucion->Pc,
                      pcb_ejecucion->IR, pcb_ejecucion->nombre, pcb_ejecucion->status);

            dibujar_listos(win_listos, 2);
            dibujar_terminados(win_term, 2);

            update_panels();
            doupdate();
            usleep(700000);

            // === Manejo de fin o error ===
            if (fin == -1 || fin == 1)
            {
                if (fin == -1)
                    strncpy(pcb_ejecucion->status, "Error", sizeof(pcb_ejecucion->status) - 1);
                else
                    strncpy(pcb_ejecucion->status, "Correcto", sizeof(pcb_ejecucion->status) - 1);

                GuardarContexto(pcb_ejecucion);
                anexar_terminado_final(pcb_ejecucion);

                // Tras finalizar un proceso, mover nuevos a listos
                planificador_largo_plazo();
                dibujar_nuevos(win_nuevos, 2);
                dibujar_listos(win_listos, 2);
                dibujar_terminados(win_term, 2);
                update_panels();
                doupdate();

                werase(win_ejec);
                box(win_ejec, 0, 0);
                wattron(win_ejec, COLOR_PAIR(4));
                mvwprintw(win_ejec, 0, 2, " EJECUCION (Quantum = %d) ", Q);
                wattroff(win_ejec, COLOR_PAIR(4));
                wrefresh(win_ejec);

                goto finalizar_proceso;
            }

            // === Quantum alcanzado ===
            if (instrucciones_ejecutadas >= Q)
            {
                GuardarContexto(pcb_ejecucion);
                strncpy(pcb_ejecucion->status, "Listo", sizeof(pcb_ejecucion->status) - 1);
                push_listo(pcb_ejecucion);
                pcb_ejecucion = NULL;
                break;
            }
        }

        // === Finalizar proceso ===
        if (pcb_ejecucion)
        {
        finalizar_proceso:
            if (pcb_ejecucion->file)
                fclose(pcb_ejecucion->file);
            free(pcb_ejecucion);
            pcb_ejecucion = NULL;
        }

        // Al liberar un proceso, revisar si hay nuevos que puedan pasar
        planificador_largo_plazo();
        dibujar_nuevos(win_nuevos, 2);
        dibujar_listos(win_listos, 2);
        dibujar_terminados(win_term, 2);
        update_panels();
        doupdate();
    }
}

/* --- Ejecución completa con quantum (Q) y paneles ncurses --- */
int ejecutar_archivo(const char *ruta_mult)
{
    // === Limpiar listas previas ===
    while (lista_listos)
    {
        PCB *t = lista_listos;
        lista_listos = t->siguiente;
        if (t->file)
            fclose(t->file);
        free(t);
    }
    while (lista_terminados)
    {
        PCB *t = lista_terminados;
        lista_terminados = t->siguiente;
        free(t);
    }
    // Asegurarnos de limpiar tambien 'nuevos' por si hubiera restos
    while (lista_nuevos)
    {
        PCB *t = lista_nuevos;
        lista_nuevos = t->siguiente;
        if (t->file)
            fclose(t->file);
        free(t);
    }
    lista_nuevos = NULL;

    // === Cargar múltiples archivos ASM ===
    /* Inicializar generador aleatorio para prioridades (una vez por ejecución) */
    srand((unsigned int)time(NULL));
    char tmp[1024];
    strncpy(tmp, ruta_mult, sizeof(tmp) - 1);
    tmp[sizeof(tmp) - 1] = '\0';
    char *tok = strtok(tmp, " ");
    int proc_id = 1;

    while (tok)
    {
        FILE *f = fopen(tok, "r");
        if (!f)
        {
            printf("No se pudo abrir: %s\n", tok);
            // continuar con el resto en lugar de abortar totalmente
            tok = strtok(NULL, " ");
            continue;
        }
        PCB *p = (PCB *)malloc(sizeof(PCB));
        crear_PCB(p, proc_id++, tok, f); // asumo que crear_PCB deja f en p->file
        push_nuevo(p);
        tok = strtok(NULL, " ");
    }

    // === Inicialización de ncurses ===
    initscr();
    cbreak();
    noecho();
    curs_set(0);
    start_color();

    init_pair(1, COLOR_CYAN, COLOR_BLACK);   // Encabezado
    init_pair(2, COLOR_GREEN, COLOR_BLACK);  // Listos
    init_pair(3, COLOR_RED, COLOR_BLACK);    // Terminados
    init_pair(4, COLOR_YELLOW, COLOR_BLACK); // Ejecución
    init_pair(5, COLOR_WHITE, COLOR_BLACK);  // General

    // === Crear ventanas (usar las variables globales) ===
    int mid_x = COLS / 2;
    int mid_y = LINES / 2;

    // Usamos las variables globales (declaradas fuera en el header)
    win_ejec = newwin(8, COLS - 2, 1, 1);
    win_nuevos = newwin((mid_y - 12 > 4 ? mid_y - 12 : 4), mid_x - 2, 10, 1);
    win_listos = newwin((mid_y - 12 > 4 ? mid_y - 12 : 4), mid_x - 2, 10, mid_x + 1);
    win_term = newwin(LINES - mid_y - 2 > 4 ? LINES - mid_y - 2 : 4, COLS - 2, mid_y + 1, 1);

    // Crear panels (pueden ser locales)
    PANEL *pnl_ejec = new_panel(win_ejec);
    PANEL *pnl_nuevos = new_panel(win_nuevos);
    PANEL *pnl_listos = new_panel(win_listos);
    PANEL *pnl_term = new_panel(win_term);

    // Dibujar bordes y títulos
    box(win_ejec, 0, 0);
    wattron(win_ejec, COLOR_PAIR(4));
    mvwprintw(win_ejec, 0, 2, " EJECUCION (Quantum = %d) ", Q);
    wattroff(win_ejec, COLOR_PAIR(4));

    box(win_nuevos, 0, 0);
    wattron(win_nuevos, COLOR_PAIR(5));
    mvwprintw(win_nuevos, 0, 2, " NUEVOS ");
    wattroff(win_nuevos, COLOR_PAIR(5));

    box(win_listos, 0, 0);
    wattron(win_listos, COLOR_PAIR(2));
    mvwprintw(win_listos, 0, 2, " LISTOS ");
    wattroff(win_listos, COLOR_PAIR(2));

    box(win_term, 0, 0);
    wattron(win_term, COLOR_PAIR(3));
    mvwprintw(win_term, 0, 2, " TERMINADOS ");
    wattroff(win_term, COLOR_PAIR(3));

    update_panels();
    doupdate();

    // Dibujar los procesos nuevos inicialmente y planificar
    dibujar_nuevos(win_nuevos, 2);

    // Ejecutar el planificador a largo plazo primero para llenar "listos" desde "nuevos"
    planificador_largo_plazo();

    // Redibujar nuevos y listos después de la planificación inicial
    dibujar_nuevos(win_nuevos, 2);
    dibujar_listos(win_listos, 2);
    update_panels();
    doupdate();

    // === Bucle principal de la simulación ===
    // Ejecutamos el corto plazo tantas veces como sea necesario mientras haya trabajo
    while (lista_listos != NULL || lista_nuevos != NULL)
    {
        // Si no hay procesos listos pero hay nuevos, intentar moverlos
        if (!lista_listos && lista_nuevos)
        {
            planificador_largo_plazo();
            dibujar_nuevos(win_nuevos, 2);
            dibujar_listos(win_listos, 2);
            update_panels();
            doupdate();
        }

        // Ejecuta el planificador corto (procesa todos los listos disponibles)
        planificador_corto_plazo(win_ejec, win_listos, win_term);

        // Después de una ejecución corta, intentar mover nuevos a listos (si hay espacio)
        planificador_largo_plazo();

        // Redibujar todo
        dibujar_nuevos(win_nuevos, 2);
        dibujar_listos(win_listos, 2);
        dibujar_terminados(win_term, 2);
        update_panels();
        doupdate();

        // pequeña pausa para evitar loop demasiado rápido (opcional)
        usleep(100000);
    }

    // === Mensaje final ===
    werase(win_ejec);
    box(win_ejec, 0, 0);
    wattron(win_ejec, COLOR_PAIR(2));
    mvwprintw(win_ejec, 1, 2, "Ejecución finalizada. Presiona una tecla para salir...");
    wattroff(win_ejec, COLOR_PAIR(2));
    wrefresh(win_ejec);
    getch();

    // === Limpieza ===
    del_panel(pnl_ejec);
    del_panel(pnl_nuevos);
    del_panel(pnl_listos);
    del_panel(pnl_term);

    delwin(win_ejec);
    delwin(win_nuevos);
    delwin(win_listos);
    delwin(win_term);

    // dejar punteros globals a NULL por seguridad
    win_ejec = win_nuevos = win_listos = win_term = NULL;

    endwin();
    return 0;
}

#endif

